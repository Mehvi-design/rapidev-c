<h1>Task Guidelines</h1>
<ul>
        <li>Each task should have its own file</li>
        <li>You can add main function for testing only. After testing remove it</li>
        <li>Use single line and multi line comments to explain code where necessary</li>
        <li>All task files should be submitted in single zipped file</li>
        <li>Read given material for reference only, online help is highly discourged</li>
        <li>Discuss any confusion in chat</li>
</ul>
<h1>Loops, Conditionals, Logical Operators, String Comparison</h1>
<h1>1. Loop Constructs</h1>
<h2><strong>Task: Count from 1 to 10</strong>**</h2>
<h4>Objective: Use a for loop to print numbers 1 to 10.</h4>
<pre><code>void print_1_to_10();
</code></pre>
<h2><strong>Task: Sum of First N Numbers</strong>**</h2>
<h4>Objective: Read N from input, use a while loop to compute the sum.</h4>
<pre><code>int sum_upto_n(int n); Returns sum 1+2+...+n
</code></pre>
<h2><strong>Task: Even Numbers Between A and B</strong>**</h2>
<h4>Objective: Use a for loop to print even numbers between two inputs a and b.</h4>
<h2><strong>Task: Password Retry (do-while)</strong>**</h2>
<h4>Objective: Allow user up to 3 tries to input a correct password using a do-while loop.</h4>
<pre><code>void check_password();  // Assume correct password = &quot;1234&quot;
</code></pre>
<h2><strong>Task: Multiplication Table Generator</strong>**</h2>
<h4>Objective: Print multiplication table of a given number (up to 10x).</h4>
<h2><strong>Task: Prime Number Checker with Loop</strong></h2>
<h4>Objective: Use a loop to check if input n is a prime number.</h4>
<h2><strong>Task: Nested Loops: Print Pattern</strong></h2>
<h4>Objective: Print a right-angled triangle pattern using *.</h4>
<p>Example for n = 3:</p>
<p>*</p>
<p>**</p>
<p>***</p>
<h2><strong>Task: Loop-Controlled LED Pattern (Simulation)</strong></h2>
<h4>Objective: Simulate an 8-bit LED pattern shift to the left every 500ms (use for loop and bit shift logic).</h4>
<pre><code>void simulate_led_shift();
</code></pre>
<h2><strong>Task: Debounce Button Press Simulation</strong></h2>
<h4>Objective: Simulate a polling loop checking a “button” value. Consider button stable only if high for 5 consecutive
        iterations.</h4>
<pre><code>// Simulated GPIO samples
bool debounce_button(const bool samples[], int length);  
</code></pre>
<h2><strong>Task: Event Counter from GPIO Sample Stream</strong></h2>
<h4>Objective: Loop through array of GPIO states (0/1) and count how many falling edges occurred.</h4>
<pre><code>int count_falling_edges(const bool signal[], int len);
</code></pre>
<h2><strong>Task: Run-Length Encoding (Loop with Lookahead)</strong></h2>
<h4>Objective: Compress a string by counting repeated characters using a for loop.</h4>
<p>Example:<br />
        Input: &quot;aaabbc&quot;<br />
        Output: &quot;a3b2c1&quot;</p>
<h2><strong>Task: Implement Circular Buffer Access</strong></h2>
<h4>Objective: Use a loop to read and print N elements from a circular buffer starting from an index.</h4>
<pre><code>void print_circular_buffer(int *buffer, int size, int start, int count);
</code></pre>
<h3><strong>Hints/Tips</strong></h3>
<ul>
        <li>Use comments to describe loop intent.</li>
        <li>Pay attention to loop conditions and off-by-one errors.</li>
        <li>Simulate embedded inputs using arrays or constants.</li>
        <li>Use break, continue sparingly and only with clear intent.</li>
</ul>
<h1>2. Bitwise, and Logical Operations</h1>
<h2><strong>Task: Logical Access Control</strong></h2>
<h4>Objective: Check if a user is allowed access based on is_admin or has_token.</h4>
<pre><code>bool check_access(bool is_admin, bool has_token);
</code></pre>
<h2><strong>Task: Bitwise Flag Tester</strong></h2>
<h4>Objective: Use bitwise AND to test if specific flags are enabled in a 1-byte status register.</h4>
<pre><code>#define FLAG_TX_READY  (1 &lt;&lt; 0)
#define FLAG_RX_READY  (1 &lt;&lt; 1)
#define FLAG_ERROR     (1 &lt;&lt; 2)
bool is_flag_set(uint8_t status, uint8_t flag);
</code></pre>
<h2><strong>Task: Toggle Bit Using XOR</strong></h2>
<h4>Objective: Toggle a bit in an 8-bit register using XOR.</h4>
<pre><code>uint8_t toggle_bit(uint8_t reg, uint8_t bit_pos);
</code></pre>
<h2><strong>Task: Extract Specific Bits</strong></h2>
<h4>Objective: Extract bits [5:3] from a byte using masking and shifting.</h4>
<pre><code>// e.g., input: 0b10111000 → output: 0b011
uint8_t extract_bits(uint8_t reg);  
</code></pre>
<h2><strong>Task: Pack Two 4-bit Values</strong></h2>
<h4>Objective: Pack two 4-bit values into a single byte.</h4>
<pre><code>// high in bits [7:4], low in [3:0]
uint8_t pack_4bit(uint8_t high, uint8_t low); 
</code></pre>
<h2><strong>Task: Unpack Packed Byte</strong></h2>
<h4>Objective: Given a packed byte, extract the high and low 4-bit values.</h4>
<pre><code>void unpack_4bit(uint8_t packed, uint8_t *high, uint8_t *low);
</code></pre>
<h2><strong>Task: Bitfield Status Encoder</strong></h2>
<h4>Objective: Use bitwise OR to encode multiple sensor statuses into a single byte.</h4>
<pre><code>#define SENSOR_TEMP    (1 &lt;&lt; 0)
#define SENSOR_PRESS   (1 &lt;&lt; 1)
#define SENSOR_VIB     (1 &lt;&lt; 2)
uint8_t encode_sensors(bool temp, bool press, bool vib);
</code></pre>
<h2><strong>Task: Logic-Based Sensor Decision</strong></h2>
<h4>Objective: Use logical operators to decide if a sensor value should trigger an alert.</h4>
<pre><code>bool should_alert(int temp, int pressure, bool enabled);
</code></pre>
<h2><strong>Task: Emulate GPIO Register with Set/Clear/Check</strong></h2>
<h4>Objective: Simulate a GPIO port and perform bit-level operations.</h4>
<pre><code>void set_gpio(uint8_t *port, uint8_t pin);
void clear_gpio(uint8_t *port, uint8_t pin);
bool read_gpio(uint8_t port, uint8_t pin);
</code></pre>
<h2><strong>Task: Bitmask-Based Permissions</strong></h2>
<h4>Objective: Implement a permission system using bitmasks (READ, WRITE, EXEC).</h4>
<pre><code>#define PERM_READ  (1 &lt;&lt; 0)
#define PERM_WRITE (1 &lt;&lt; 1)
#define PERM_EXEC  (1 &lt;&lt; 2)
bool has_permission(uint8_t user_perm, uint8_t required_perm);
</code></pre>
<h2><strong>Task: Logical Operator Decision Tree</strong></h2>
<h4>Objective: Implement a logic tree using &amp;&amp;, ||, and ! to evaluate system health.</h4>
<pre><code>bool system_health_ok(bool sensor_ok, bool memory_ok, bool watchdog_triggered);
</code></pre>
<h2><strong>Task: Bit Reversal Using Loops</strong></h2>
<h4>Objective: Reverse the bits of a byte using bitwise operations.</h4>
<pre><code>uint8_t reverse_bits(uint8_t byte);  // e.g., 0b10000001 → 0b10000001
</code></pre>
<h2><strong>Task: Parity Bit Calculator</strong></h2>
<h4>Objective: Calculate even parity of an 8-bit data word.</h4>
<pre><code>bool calculate_even_parity(uint8_t byte);  // Return 1 if parity is even
</code></pre>
<h2><strong>Task: Simulate I/O Port with Bitfields and Access Macros</strong></h2>
<h4>Objective: Combine all prior tasks to simulate a full I/O port driver.</h4>
<pre><code>typedef struct {
uint8_t direction;
uint8_t output;
uint8_t input;
} GPIO_Port;
</code></pre>
<h3><strong>Hints</strong></h3>
<ul>
        <li>Add macros/functions to:</li>
        <li>Set pin direction</li>
        <li>Read/write individual pins</li>
        <li>Apply masks to toggle groups</li>
</ul>
<h1>3. String operations</h1>
<h2><strong>Task: Manual String Length</strong></h2>
<h4>Objective: Write a function to calculate the length of a null-terminated string without using strlen.</h4>
<pre><code>size_t my_strlen(const char *str);
</code></pre>
<h2><strong>Task: Case Conversion (Uppercase)</strong></h2>
<h4>Objective: Convert all lowercase characters in a string to uppercase using ASCII or toupper().</h4>
<pre><code>void str_to_upper(char *str);
</code></pre>
<h2><strong>Task: String Comparison (Case-Insensitive)</strong></h2>
<h4>Objective: Write your own strcmp_case_insensitive without using strcasecmp.</h4>
<pre><code>// return 0 if equal
int strcmp_case_insensitive(const char *a, const char *b); 
</code></pre>
<h2><strong>Task: Reverse a String In-Place</strong></h2>
<h4>Objective: Reverse a null-terminated string without using additional arrays.</h4>
<pre><code>void reverse_string(char *str);
</code></pre>
<h2><strong>Task: Count Words in a Sentence</strong></h2>
<h4>Objective: Count how many words are in a sentence (separated by spaces).</h4>
<pre><code>int count_words(const char *sentence);
</code></pre>
<h2><strong>Task: Extract Words Using strtok</strong></h2>
<h4>Objective: Split a command string into tokens and print each.</h4>
<pre><code>void split_command(const char *cmd); // Input: &quot;SET TEMP 25&quot;
</code></pre>
<h2><strong>Task: Find Substring (Naive Search)</strong></h2>
<h4>Objective: Implement a basic strstr function to find a substring.</h4>
<pre><code>char *my_strstr(const char *haystack, const char *needle);
</code></pre>
<h2><strong>Task: Prefix and Suffix Match</strong></h2>
<h4>Objective: Check if a string starts or ends with a given keyword.</h4>
<pre><code>bool starts_with(const char *str, const char *prefix);
bool ends_with(const char *str, const char *suffix);
</code></pre>
<h2><strong>Task: Clean Extra Spaces</strong></h2>
<h4>Objective: Trim leading/trailing spaces and reduce multiple spaces between words to one.</h4>
<pre><code>void clean_spaces(char *str);
</code></pre>
<h2><strong>Task: Command Parser for Key/Value Pair</strong></h2>
<h4>Objective: Parse string in the form &quot;key=value&quot; into separate key and value strings.</h4>
<pre><code>bool parse_kv_pair(const char *input, char *key, char *value);
</code></pre>
<h2><strong>Task: Case-Insensitive Command Matcher</strong></h2>
<h4>Objective: Match an input string to a list of commands regardless of case.</h4>
<pre><code>const char *match_command(const char *input);
</code></pre>
<h2><strong>Task: Parse and Convert Numbers from Strings</strong></h2>
<h4>Objective: Extract integers and floats from strings.</h4>
<pre><code>int parse_int(const char *str);   // e.g., &quot;TEMP=25&quot; → 25
float parse_float(const char *str); // e.g., &quot;VOLT=3.3&quot; → 3.3
</code></pre>
<h2><strong>Task: Format Sensor Data as JSON</strong></h2>
<h4>Objective: Construct a JSON-like string from sensor values.</h4>
<pre><code>// Output → {&quot;sensor&quot;:&quot;TEMP&quot;,&quot;value&quot;:25.5}
void format_sensor_json(char *out, const char *name, float value);
</code></pre>
<h2><strong>Task: Command Dispatcher</strong></h2>
<h4>Objective: Parse a full command like &quot;SET TEMP 25&quot; and call appropriate handlers.</h4>
<pre><code>typedef enum { CMD_SET, CMD_READ, CMD_INVALID } CommandType;
CommandType parse_command(const char *input);
void execute_command(const char *input);
</code></pre>
<h2><strong>Task: Mini CLI Shell Parser</strong></h2>
<h4>Objective: Build a mini interpreter for commands:</h4>
<p>• &quot;SET <code>&lt;param&gt;</code> <code>&lt;value&gt;</code>&quot;<br />
        • &quot;GET <code>&lt;param&gt;</code>&quot;<br />
        • &quot;LIST&quot;<br />
        Store parameters in a small struct and return values accordingly.</p>
<pre><code>typedef struct {
char param[16];
char value[16];
} Param;

void cli_shell();  // infinite loop using fgets() to accept and parse input
</code></pre>
<h2><strong>Hints</strong></h2>
<ul>
        <li>Always ensure null-termination when manipulating strings.</li>
        <li>Be cautious with buffer sizes: use snprintf, not sprintf.</li>
        <li>Avoid dynamic allocation if not necessary—use stack buffers.</li>
</ul>